// Core python language, nothing fancy, keep it simple.

use crate::ast;
use crate::token::Token;
use crate::lexer;

grammar;

pub Program: ast::Program = {
    <functions:FunctionDef*> => {
        ast::Program { functions }
    },
};

FunctionDef: ast::FunctionDef = {
    "def" <name:Identifier> "(" <parameters:OneOrMore<FunctionParameter>> ")" "->" <result:Expression> ":" <body:Suite> => {
        ast::FunctionDef { name, parameters, result, body }
    }
};

FunctionParameter: ast::Parameter = {
    <name:Identifier> ":" <typ:Expression> => {
        ast::Parameter { name, typ }
    }
};

Suite: Vec<ast::Statement> = {
    Indent <statements:Statement+> Dedent => statements
};

Statement: ast::Statement = {
    "return" <expr:Expression> => {
        ast::Statement::Return(expr)
    },
    "if" <condition:Test> ":" <suite:Suite> "else" ":" <else_suite:Suite> => {
        ast::Statement::If { condition: Box::new(condition), suite: Box::new(suite), else_suite: Box::new(else_suite) }
    },
    "while" <condition:Test> ":" <suite:Suite> => {
        ast::Statement::While { condition: Box::new(condition), suite: Box::new(suite) }
    },
    "for" <target:Identifier> "in" <iter:Expression> ":" <suite:Suite> => {
        ast::Statement::For { target, iter: Box::new(iter), suite: Box::new(suite) }
    },
    "break" => ast::Statement::Break,
    "continue" => ast::Statement::Continue,
};

Test: ast::Expression = {
    <e1:Expression> <op:Comparison> <e2:Expression> => {
        ast::Expression::Comparison { a: Box::new(e1), op, b: Box::new(e2) }
    }
};

Comparison: ast::Comparison = {
    "<" => ast::Comparison::Lt,
    ">" => ast::Comparison::Gt,
    "<=" => ast::Comparison::Le,
    ">=" => ast::Comparison::Ge,
    "==" => ast::Comparison::Equal,
    "!=" => ast::Comparison::NotEqual,
};

Expression: ast::Expression = {
    ArithmatricExpression,
};

ArithmatricExpression: ast::Expression = {
    <a:ArithmatricExpression> <op:AddOp> <b:Term> => {
        ast::Expression::BinaryOperation { a: Box::new(a), op, b: Box::new(b) }
    },
    Term,
};

AddOp: ast::BinaryOperation = {
    "+" => ast::BinaryOperation::Add,
    "-" => ast::BinaryOperation::Sub,
};

Term: ast::Expression = {
    Factor,
};

Factor: ast::Expression = {
    Atom,
};

Atom: ast::Expression = {
    <n:Number> => {
        ast::Expression::Number(n)
    },
    <n:Identifier> => {
        ast::Expression::Identifier(n)
    }
};

#[inline]
OneOrMore<T>: Vec<T> = {
    <i1: T> <i2:("," T)*> => {
        let mut items = vec![i1];
        items.extend(i2.into_iter().map(|e| e.1));
        items
    }
};

extern {
    type Location = lexer::Location;
    type Error = lexer::LexicalError;

    enum Token {
        Number => Token::Number { value: <i32> },
        Identifier => Token::Identifier { value: <String> },
        Indent => Token::Indent,
        Dedent => Token::Dedent,
        "and" => Token::KeywordAnd,
        "break" => Token::KeywordBreak,
        "continue" => Token::KeywordContinue,
        "def" => Token::KeywordDef,
        "else" => Token::KeywordElse,
        "for" => Token::KeywordFor,
        "if" => Token::KeywordIf,
        "in" => Token::KeywordIn,
        "or" => Token::KeywordOr,
        "return" => Token::KeywordReturn,
        "while" => Token::KeywordWhile,
        "(" => Token::OpeningParenthesis,
        ")" => Token::ClosingParenthesis,
        "," => Token::Comma,
        ":" => Token::Colon,
        "+" => Token::Plus,
        "*" => Token::Asterix,
        "<" => Token::Less,
        ">" => Token::Greater,
        "<=" => Token::LessEqual,
        ">=" => Token::GreaterEqual,
        "==" => Token::EqualEqual,
        "!=" => Token::NotEqual,
        "-" => Token::Minus,
        "->" => Token::Arrow,
    }
}
